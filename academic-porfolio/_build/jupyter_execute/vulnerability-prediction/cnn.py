#!/usr/bin/env python
# coding: utf-8

# # CNN

# In[1]:


# University of Notre Dame
# Multi Layer Perceptron (MLP) for "Vulnerability Prediction From Source Code Using Machine Learning"
# _________________________________________________________________________
# Pedro Alarcon, April 2022


# In[4]:


import pandas as pd 
import numpy as np
import argparse
import math
import string
from collections.abc import Iterable
from collections import Counter
import pandas as pd 

from sklearn.preprocessing import LabelEncoder,  OneHotEncoder
import argparse
from sklearn.metrics import accuracy_score

from tensorflow import keras
from keras.models import Sequential
from keras.layers import Dense, Conv1D, Flatten

from sklearn.metrics import roc_curve
from sklearn.metrics import auc
from sklearn import datasets, metrics
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import average_precision_score, precision_recall_curve
from sklearn.metrics import auc, plot_precision_recall_curve
import matplotlib.pyplot as plt
from matplotlib import pyplot
from sklearn.metrics import classification_report
import os
from sklearn.model_selection import train_test_split
print(os.getcwd())


# In[3]:


from google.colab import drive
drive.mount('/content/drive')


# # Impact of Depth Analysis

# In[6]:


#folder_path = '/scratch365/palarcon/Vulnerability Project/CNN/train/'

folder_path = '/content/drive/MyDrive/Vulnerability Prediction/Processed Datasets/'

def load_data(path, column, rdm_state):
    dataframe = pd.read_csv(path)
    
    y = dataframe[column].astype(int) # numberize the labels i.e., tranforms True = 1, False = 0
    print("Label Distribution: ")
    print(y.value_counts())

    y = y.values 
    
    X = dataframe.iloc[:, 7:]
    num_features = len(X.columns) 
    X = X.values

    X = np.reshape(X, (len(X), num_features, 1)) 


    print("Dataset: ")
    print(f"\nShape of features: {X.shape} (# samples, # features, channel) of type {type(X)}" )
    print(f"Shape of labels: {y.shape} (# samples, ) of type {type(X)}" )
    
    
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.10, random_state=rdm_state)

    return X_train, X_test, y_train, y_test




X_cwe_119_train, X_cwe_119_test, y_cwe_119_train, y_cwe_119_test = load_data(folder_path + 'cwe_119_train.csv', 'CWE-119', 42)


# In[12]:


def cnn_model(num_features):
  model = Sequential()
  #add layers
  model.add(Conv1D( input_shape = (num_features, 1), filters=32, kernel_size=9, activation='relu'))
  model.add(Flatten())
  model.add(Dense(200, activation = 'relu'))
  model.add((Dense(1, activation='sigmoid')))
  model.summary()
  model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

  return model

cwe_119_model = cnn_model(1533)
#load trained model
cwe_119_model = keras.models.load_model('/content/drive/MyDrive/Vulnerability Prediction/CNN/cwe_119_model.ph')


# In[ ]:


# fit network
#uncomment the below statement to train new model 
#history = cwe_119_model.fit(X_cwe_119_train, y_cwe_119_train, epochs=10, verbose=2)


# In[23]:


def run_acccuracy(model, X, y):
  loss, acc = model.evaluate(X, y, verbose=0)
  print(f'Test Accuracy: {acc*100}')


run_acccuracy(cwe_119_model,X_cwe_119_test, y_cwe_119_test)


# In[9]:


def generate_roc_plot(model, x_test, y_test):
  # Generate a prediction using model.predict() 
  # and calculate it's shape:
  print("Generate a prediction")
  prediction = model.predict(x_test).ravel()
  print("prediction shape:", prediction.shape)

  fpr_keras, tpr_keras, thresholds_keras = roc_curve(y_test, prediction)
  auc_keras = auc(fpr_keras, tpr_keras)

  #generate plot
  plt.figure(1)
  plt.plot([0, 1], [0, 1], 'k--')
  plt.plot(fpr_keras, tpr_keras, label=' (area = {:.3f})'.format(auc_keras))
  plt.xlabel('False positive rate')
  plt.ylabel('True positive rate')
  plt.title('ROC curve')
  plt.legend(loc='best')
  plt.show()


# In[10]:


generate_roc_plot(cwe_119_model,X_cwe_119_test, y_cwe_119_test)


# In[ ]:


#cwe_119_model.save('/scratch365/palarcon/Vulnerability Project/CNN/cwe_119_model.ph')


# # CWE-120

# In[13]:


X_cwe_120_train, X_cwe_120_test, y_cwe_120_train, y_cwe_120_test = load_data(folder_path + 'cwe_120_train.csv', 'CWE-120', 45)
cwe_120_model = cnn_model(1533)
# fit network



# In[ ]:


#history = cwe_120_model.fit(X_cwe_120_train, y_cwe_120_train, epochs=20, verbose=2)


# In[14]:


cwe_120_model = keras.models.load_model('/content/drive/MyDrive/Vulnerability Prediction/CNN/cwe_120_model.ph')
generate_roc_plot(cwe_120_model, X_cwe_120_test, y_cwe_120_test)


# In[ ]:


cwe_120_model.save('/scratch365/palarcon/Vulnerability Project/CNN/cwe_120_model.ph')


# # CSE 469

# In[15]:


X_cwe_469_train, X_cwe_469_test, y_cwe_469_train, y_cwe_469_test = load_data(folder_path + 'cwe_469_train.csv', 'CWE-469', 40)
cwe_469_model = cnn_model(1533)
cwe_469_model = keras.models.load_model('/content/drive/MyDrive/Vulnerability Prediction/CNN/cwe_469_model.ph')


# In[ ]:


# fit network
#uncomment below to train new model
#history = cwe_469_model.fit(X_cwe_469_train, y_cwe_469_train, epochs=10, verbose=2)


# In[16]:


generate_roc_plot(cwe_469_model, X_cwe_469_test, y_cwe_469_test)


# In[ ]:


#cwe_469_model.save('/scratch365/palarcon/Vulnerability Project/CNN/cwe_469_model.ph')


# # CWE 476

# In[17]:


X_cwe_476_train, X_cwe_476_test, y_cwe_476_train, y_cwe_476_test = load_data(folder_path + 'cwe_476_train.csv', 'CWE-476', 40)
cwe_476_model = cnn_model(1533)
cwe_476_model = keras.models.load_model('/content/drive/MyDrive/Vulnerability Prediction/CNN/cwe_476_model.ph')


# In[ ]:


# fit network
history = cwe_476_model.fit(X_cwe_476_train, y_cwe_476_train, epochs=10, verbose=2)


# In[18]:


generate_roc_plot(cwe_476_model, X_cwe_476_test, y_cwe_476_test)


# In[ ]:


#cwe_476_model.save('/scratch365/palarcon/Vulnerability Project/CNN/cwe_476_model.ph')


# # CWE Other

# In[19]:


X_cwe_other_train, X_cwe_other_test, y_cwe_other_train, y_cwe_other_test = load_data(folder_path + 'cwe_other_train.csv', 'CWE-other', 40)
cwe_other_model = cnn_model(1533)
cwe_other_model = keras.models.load_model('/content/drive/MyDrive/Vulnerability Prediction/CNN/cwe_other_model.ph')


# In[ ]:


# fit network
#history = cwe_other_model.fit(X_cwe_other_train, y_cwe_other_train, epochs=10, verbose=2)


# In[20]:


generate_roc_plot(cwe_other_model, X_cwe_other_test, y_cwe_other_test)


# In[ ]:


#cwe_other_model.save('/scratch365/palarcon/Vulnerability Project/CNN/cwe_other_model.ph')


# # Validation Inference

# In[21]:


def generate_roc_plots(models, x_test, y_test, names):
  # Generate a prediction using model.predict() 
  # and calculate it's shape:
    
    fpr, tpr, aucs = [], [], []
    
    #Generate a prediction
    for i in range(len(models)):
        model = models[i]
        pred = model.predict(x_test[i]).ravel()
        
        fpr_keras, tpr_keras, thresholds_keras = roc_curve(y_test[i], pred)
        auc_keras = auc(fpr_keras, tpr_keras)
        
        fpr.append(fpr_keras)
        tpr.append(tpr_keras)
        aucs.append(auc_keras)

    
    #generate plot
    plt.figure(figsize=(9,9))
    plt.plot([0, 1], [0, 1], 'k--')
    for i in range(len(models)):
        plt.plot(fpr[i], tpr[i], label=' {} (area = {:.3f})'.format(names[i],aucs[i]))
    
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('ROC curve')
    plt.legend(loc='best')
    plt.show()


# In[24]:


mod = [cwe_119_model, cwe_other_model, cwe_120_model, cwe_469_model, cwe_476_model]
x_tests = [X_cwe_119_test, X_cwe_other_test, X_cwe_120_test, X_cwe_469_test, X_cwe_476_test]
y_tests = [y_cwe_119_test, y_cwe_other_test, y_cwe_120_test, y_cwe_469_test, y_cwe_476_test]
names = ['CWE-119', 'CWE-Oth', 'CWE-120', 'CWE-469','CWE-476']
generate_roc_plots(mod, x_tests, y_tests, names)


# In[25]:


def classificationReport(model, X, y):
    # make a prediction on the test set
    yhat = model.predict(X)
    # round probabilities to class labels
    yhat = yhat.round()
    
    print(classification_report(y, yhat))


# In[26]:


for i in range(len(mod)):
    print(names[i])
    classificationReport(mod[i], x_tests[i], y_tests[i])

